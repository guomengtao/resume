<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC + Supabase æœ€ç®€ Demo</title>
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <style>
        .signal-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            margin-right: 5px;
            vertical-align: text-bottom;
        }
        .signal-offer {
            background-color: #4caf50; /* ç»¿è‰² */
            border-radius: 50%;
        }
        .signal-answer {
            background-color: #2196f3; /* è“è‰² */
            border-radius: 50%;
        }
        .signal-candidate {
            background-color: #ff9800; /* æ©™è‰² */
            border-radius: 50%;
        }
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .container {
            display: flex;
            gap: 20px;
        }
        .user-panel {
            flex: 1;
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 5px;
        }
        button {
            display: block;
            margin: 10px 0;
            padding: 8px 12px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        /* æ·»åŠ ç‚¹å‡»åçš„æŒ‰é’®æ ·å¼ */
        button.clicked {
            background: #4ade80; /* æ·¡ç»¿è‰² */
            color: black;
            border: 1px solid #3b3b3b;
        }
        .status {
            margin-top: 20px;
            padding: 10px;
            border-radius: 4px;
            background: #f0f0f0;
        }
        .success {
            color: green;
        }
        .error {
            color: red;
        }
        video {
            width: 100%;
            max-width: 300px;
            background: #000;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>WebRTC + Supabase æœ€ç®€ Demo</h1>
    <p>ä½¿ç”¨æ‚¨æä¾›çš„ Supabase å‡­æ®</p>

    <!-- æ·»åŠ æµç¨‹å›¾å¼•å¯¼åŒºåŸŸ -->
    <section style="margin: 20px 0; padding: 15px; border: 2px dashed #ccc; border-radius: 8px;">
      <h2>ğŸ”„ æ“ä½œæµç¨‹æŒ‡å—</h2>
      <ol>
        <li>ç‚¹å‡»ã€Œ1. ç”¨æˆ·A - åˆå§‹åŒ– PeerConnectionã€</li>
        <li>ç‚¹å‡»ã€Œ2. ç”¨æˆ·B - åˆå§‹åŒ– PeerConnectionã€</li>
        <li>ç‚¹å‡»ã€Œ3. ç”¨æˆ·A - åˆ›å»ºå¹¶å‘é€ Offerã€</li>
        <li>ç‚¹å‡»ã€Œ4. ç”¨æˆ·B - æ ¸å®æ˜¯å¦æ”¶åˆ° Offerã€</li>
        <li>ç‚¹å‡»ã€Œ5. ç”¨æˆ·B - å›å¤ Answerã€</li>
        <li>ç‚¹å‡»ã€Œ6. ç”¨æˆ·A - ç¡®è®¤ Answerã€</li>
      </ol>
    </section>

    <div id="step-guidance" style="margin-top: 20px; padding: 12px; background: #e0f7fa; border-left: 6px solid #00796b; border-radius: 4px;">
      å½“å‰çŠ¶æ€ï¼šè¯·ç‚¹å‡»â€œ1. ç”¨æˆ·A - åˆå§‹åŒ– PeerConnectionâ€
    </div>

    <!-- çŠ¶æ€æ˜¾ç¤ºåŒºåŸŸ -->
    <section style="margin: 20px 0; padding: 10px; border: 1px solid #999; border-radius: 4px;">
      <h3>ğŸ§  å®æ—¶çŠ¶æ€æ£€æŸ¥</h3>
      <ul>
        <li>ç”¨æˆ·A localDescription ç±»å‹: <span id="aLocalDesc">æœªçŸ¥</span></li>
        <li>ç”¨æˆ·A remoteDescription ç±»å‹: <span id="aRemoteDesc">æœªçŸ¥</span></li>
        <li>ç”¨æˆ·B localDescription ç±»å‹: <span id="bLocalDesc">æœªçŸ¥</span></li>
        <li>ç”¨æˆ·B remoteDescription ç±»å‹: <span id="bRemoteDesc">æœªçŸ¥</span></li>
        <li>æœ€è¿‘ Supabase ä¿¡ä»¤ç±»å‹: <span id="lastSignalType">æš‚æ— </span></li>
      </ul>
      <button onclick="refreshDescriptions()">ğŸ”„ åˆ·æ–°çŠ¶æ€</button>
    </section>

    <div class="container">
        <div class="user-panel" id="userA">
            <h2>ç”¨æˆ· A</h2>
            <button id="initA">1. ç”¨æˆ·A - åˆå§‹åŒ– PeerConnection</button>
            <button id="offerA" disabled>3. ç”¨æˆ·A - åˆ›å»ºå¹¶å‘é€ Offer</button>
            <button id="checkOfferSentA" disabled>ç¡®è®¤ï¼šç”¨æˆ·A Offeræ˜¯å¦å·²å‘é€</button>
            <button id="confirmA" disabled>6. ç”¨æˆ·A - ç¡®è®¤ Answer</button>
            <div class="status" id="statusA">çŠ¶æ€: æœªåˆå§‹åŒ–</div>
            <video id="videoA" autoplay muted></video>
        </div>

        <div class="user-panel" id="userB">
            <h2>ç”¨æˆ· B</h2>
            <button id="initB">2. ç”¨æˆ·B - åˆå§‹åŒ– PeerConnection</button>
            <button id="checkOfferB" disabled>4. ç”¨æˆ·B - æ ¸å®æ˜¯å¦æ”¶åˆ° Offer</button>
            <button id="verifyOfferSupabase" disabled>ç¡®è®¤ï¼šSupabase æ˜¯å¦æ”¶åˆ° Offer</button>
            <button id="viewLastSignal" disabled>æŸ¥çœ‹ Supabase æœ€è¿‘ä¿¡ä»¤</button>
            <button id="answerB" disabled>5. ç”¨æˆ·B - å›å¤ Answer</button>
            <div class="status" id="statusB">çŠ¶æ€: æœªåˆå§‹åŒ–</div>
            <video id="videoB" autoplay></video>
        </div>
    </div>

    <script>
        // ä½¿ç”¨æ‚¨æä¾›çš„ Supabase å‡­æ®
        const supabaseUrl = 'https://vbpbytebpaihpauwcryn.supabase.co';
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZicGJ5dGVicGFpaHBhdXdjcnluIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk0MjgzMzcsImV4cCI6MjA2NTAwNDMzN30.fW-XLBBgtUHtMWM_DYIowqz39SZpenkmgJfE_RZuc74';
        const supabaseClient = supabase.createClient(supabaseUrl, supabaseKey);
        
        const roomId = 'demo-room-1'; // å›ºå®šæˆ¿é—´IDï¼Œå®é™…åº”ç”¨ä¸­åº”åŠ¨æ€ç”Ÿæˆ
        
        // ç”¨æˆ·Açš„å˜é‡
        let pcA;
        let localStreamA;
        const videoA = document.getElementById('videoA');
        const statusA = document.getElementById('statusA');
        const initAButton = document.getElementById('initA');
        const offerAButton = document.getElementById('offerA');
        const confirmAButton = document.getElementById('confirmA');
        const checkOfferSentAButton = document.getElementById('checkOfferSentA');

        // ç”¨æˆ·Bçš„å˜é‡
        let pcB;
        const videoB = document.getElementById('videoB');
        const statusB = document.getElementById('statusB');
        const initBButton = document.getElementById('initB');
        const answerBButton = document.getElementById('answerB');
        const checkOfferBButton = document.getElementById('checkOfferB');
        const verifyOfferSupabaseButton = document.getElementById('verifyOfferSupabase');
        const viewLastSignalButton = document.getElementById('viewLastSignal');

        // æœ€è¿‘æ”¶åˆ°çš„Supabaseä¿¡ä»¤
        let lastSupabasePayload = null;

        // ä¿¡ä»¤é¢‘é“
        const channel = supabaseClient.channel(roomId);

        // ç›‘å¬ä¿¡ä»¤æ¶ˆæ¯
        channel.on('broadcast', { event: 'webrtc_signal' }, (payload) => {
            // ä¿å­˜æœ€è¿‘çš„Supabaseä¿¡ä»¤
            lastSupabasePayload = payload.payload;
            // ğŸ”¥ è¾“å‡º Supabase æ”¶åˆ°çš„ä¿¡ä»¤ payload
            console.log('ğŸ”¥ Supabase æ”¶åˆ°ä¿¡ä»¤:', payload.payload);
            const { from, to, type, data } = payload.payload;

            // ç”¨æˆ·Bå¤„ç†Offer
            if (type === 'offer' && to === 'B') {
                console.log('â¡ï¸ æ­£åœ¨è°ƒç”¨ handleRemoteOffer()');
                handleRemoteOffer(data);
            }

            // ç”¨æˆ·Aå¤„ç†Answer
            if (type === 'answer' && to === 'A') {
                handleRemoteAnswer(data);
            }

            // å¤„ç†ICEå€™é€‰
            if (type === 'candidate') {
                const pc = to === 'A' ? pcA : pcB;
                if (pc && data) {
                    pc.addIceCandidate(new RTCIceCandidate(data))
                        .catch(e => console.error('æ·»åŠ ICEå€™é€‰å¤±è´¥:', e));
                }
            }
            // è‡ªåŠ¨åˆ·æ–°çŠ¶æ€æ˜¾ç¤º
            refreshDescriptions();
        }).subscribe();
        // çŠ¶æ€åˆ·æ–°å‡½æ•°
        function refreshDescriptions() {
            document.getElementById('aLocalDesc').textContent = pcA?.localDescription?.type || 'æ— ';
            document.getElementById('aRemoteDesc').textContent = pcA?.remoteDescription?.type || 'æ— ';
            document.getElementById('bLocalDesc').textContent = pcB?.localDescription?.type || 'æ— ';
            document.getElementById('bRemoteDesc').textContent = pcB?.remoteDescription?.type || 'æ— ';
            document.getElementById('lastSignalType').textContent = lastSupabasePayload?.type || 'æ— ';
        }

        function updateStepGuidance(message) {
            const guideBox = document.getElementById('step-guidance');
            if (guideBox) {
                guideBox.textContent = 'å½“å‰çŠ¶æ€ï¼š' + message;
            }
        }
        
        // ç”¨æˆ·Aåˆå§‹åŒ–
        initAButton.addEventListener('click', async () => {
            console.log('ç‚¹å‡»ï¼šç”¨æˆ·A - åˆå§‹åŒ– PeerConnection');
            initAButton.classList.add('clicked');
            initAButton.disabled = true;
            try {
                // è·å–æœ¬åœ°åª’ä½“æµ
                localStreamA = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                videoA.srcObject = localStreamA;
                
                // åˆ›å»ºPeerConnection
                pcA = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' }
                    ]
                });
                
                // æ·»åŠ æœ¬åœ°æµ
                localStreamA.getTracks().forEach(track => {
                    pcA.addTrack(track, localStreamA);
                });
                
                // ICEå€™é€‰å¤„ç†
                pcA.onicecandidate = (e) => {
                    if (e.candidate) {
                        channel.send({
                            type: 'broadcast',
                            event: 'webrtc_signal',
                            payload: {
                                from: 'A',
                                to: 'B',
                                type: 'candidate',
                                data: e.candidate
                            }
                        });
                    }
                };
                
                // ç›‘å¬è¿œç¨‹æµ
                pcA.ontrack = (e) => {
                    if (e.streams && e.streams[0]) {
                        videoB.srcObject = e.streams[0];
                    }
                };
                
                // æ›´æ–°çŠ¶æ€
                statusA.textContent = 'çŠ¶æ€: åˆå§‹åŒ–å®Œæˆ';
                statusA.className = 'status success';
                offerAButton.disabled = false;
                updateStepGuidance('è¯·ç‚¹å‡»â€œ3. ç”¨æˆ·A - åˆ›å»ºå¹¶å‘é€ Offerâ€');
                
            } catch (err) {
                console.error('ç”¨æˆ·Aåˆå§‹åŒ–å¤±è´¥:', err);
                statusA.textContent = `çŠ¶æ€: åˆå§‹åŒ–å¤±è´¥ - ${err.message}`;
                statusA.className = 'status error';
                updateStepGuidance('å‘ç”Ÿé”™è¯¯ï¼š' + err.message + 'ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•æˆ–æ£€æŸ¥æ­¥éª¤æ˜¯å¦é—æ¼');
            }
        });
        
        // ç”¨æˆ·Aåˆ›å»ºå¹¶å‘é€Offer
        offerAButton.addEventListener('click', async () => {
            console.log('ç‚¹å‡»ï¼šç”¨æˆ·A - åˆ›å»ºå¹¶å‘é€ Offer');
            offerAButton.classList.add('clicked');
            offerAButton.disabled = true;
            try {
                const offer = await pcA.createOffer();
                await pcA.setLocalDescription(offer);
                
                // é€šè¿‡Supabaseå‘é€Offer
                await channel.send({
                    type: 'broadcast',
                    event: 'webrtc_signal',
                    payload: {
                        from: 'A',
                        to: 'B',
                        type: 'offer',
                        data: offer
                    }
                });
                
                statusA.textContent = 'çŠ¶æ€: Offerå·²å‘é€';
                confirmAButton.disabled = false;
                checkOfferSentAButton.disabled = false;
                updateStepGuidance('è¯·åˆ‡æ¢åˆ°ç”¨æˆ·Bï¼Œç‚¹å‡»â€œ2. ç”¨æˆ·B - åˆå§‹åŒ– PeerConnectionâ€');
                
            } catch (err) {
                console.error('åˆ›å»ºOfferå¤±è´¥:', err);
                statusA.textContent = `çŠ¶æ€: Offerå‘é€å¤±è´¥ - ${err.message}`;
                statusA.className = 'status error';
                updateStepGuidance('å‘ç”Ÿé”™è¯¯ï¼š' + err.message + 'ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•æˆ–æ£€æŸ¥æ­¥éª¤æ˜¯å¦é—æ¼');
            }
        });

        checkOfferSentAButton.addEventListener('click', () => {
            console.log('ç‚¹å‡»ï¼šç¡®è®¤ç”¨æˆ·A Offeræ˜¯å¦å·²å‘é€');
            if (pcA?.localDescription?.type === 'offer') {
                alert('ç”¨æˆ·A å·²æˆåŠŸå‘é€ Offer');
            } else {
                alert('æœªæ£€æµ‹åˆ°å·²å‘é€çš„ Offer');
            }
        });
        
        // ç”¨æˆ·Aç¡®è®¤Answer
        confirmAButton.addEventListener('click', () => {
            console.log('ç‚¹å‡»ï¼šç”¨æˆ·A - ç¡®è®¤ Answer');
            confirmAButton.classList.add('clicked');
            confirmAButton.disabled = true;
            statusA.textContent = 'çŠ¶æ€: ç­‰å¾…ICEè¿æ¥...';
            updateStepGuidance('è¿æ¥å»ºç«‹ä¸­ï¼Œè¯·ç¨å€™...');
        });
        
            // ç”¨æˆ·Båˆå§‹åŒ–
            initBButton.addEventListener('click', async () => {
                console.log('ç‚¹å‡»ï¼šç”¨æˆ·B - åˆå§‹åŒ– PeerConnection');
                initBButton.classList.add('clicked');
                initBButton.disabled = true;
                try {
                    // åˆ›å»ºPeerConnection
                    pcB = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' }
                        ]
                    });

                // ICEå€™é€‰å¤„ç†
                pcB.onicecandidate = (e) => {
                    if (e.candidate) {
                        channel.send({
                            type: 'broadcast',
                            event: 'webrtc_signal',
                            payload: {
                                from: 'B',
                                to: 'A',
                                type: 'candidate',
                                data: e.candidate
                            }
                        });
                    }
                };

                // ç›‘å¬è¿œç¨‹æµ
                pcB.ontrack = (e) => {
                    if (e.streams && e.streams[0]) {
                        videoA.srcObject = e.streams[0];
                    }
                };

                // æ›´æ–°çŠ¶æ€
                statusB.textContent = 'çŠ¶æ€: åˆå§‹åŒ–å®Œæˆ';
                statusB.className = 'status success';
                checkOfferBButton.disabled = false;
                answerBButton.disabled = false;
                checkOfferBButton.disabled = false;
                verifyOfferSupabaseButton.disabled = false;
                viewLastSignalButton.disabled = false;
                updateStepGuidance('è¯·ç‚¹å‡»â€œ4. ç”¨æˆ·B - æ ¸å®æ˜¯å¦æ”¶åˆ° Offerâ€');

            } catch (err) {
                console.error('ç”¨æˆ·Båˆå§‹åŒ–å¤±è´¥:', err);
                statusB.textContent = `çŠ¶æ€: åˆå§‹åŒ–å¤±è´¥ - ${err.message}`;
                statusB.className = 'status error';
                updateStepGuidance('å‘ç”Ÿé”™è¯¯ï¼š' + err.message + 'ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•æˆ–æ£€æŸ¥æ­¥éª¤æ˜¯å¦é—æ¼');
            }
        });
        
        checkOfferBButton.addEventListener('click', async () => {
            console.log('ç‚¹å‡»ï¼šç”¨æˆ·B - æ ¸å®æ˜¯å¦æ”¶åˆ° Offer');
            if (pcB?.remoteDescription?.type === 'offer') {
                alert('ç”¨æˆ·B å·²æˆåŠŸæ”¶åˆ° Offer');
            } else if (lastSupabasePayload?.type === 'offer') {
                try {
                    await pcB.setRemoteDescription(new RTCSessionDescription(lastSupabasePayload.data));
                    alert('ç”¨æˆ·B æ‰‹åŠ¨è®¾ç½® remoteDescription æˆåŠŸ');
                } catch (err) {
                    alert('è®¾ç½® remoteDescription å¤±è´¥ï¼š' + err.message);
                }
            } else {
                alert('ç”¨æˆ·B å°šæœªæ¥æ”¶åˆ°æœ‰æ•ˆçš„ Offer');
            }
        });

        // Supabase Offer éªŒè¯æŒ‰é’®
        verifyOfferSupabaseButton.addEventListener('click', () => {
            console.log('ç‚¹å‡»ï¼šç¡®è®¤ Supabase æ˜¯å¦æ”¶åˆ° Offer');
            alert('è¯·æŸ¥çœ‹æ§åˆ¶å°è¾“å‡ºæ˜¯å¦æœ‰ payload ä¸­åŒ…å« type: "offer" çš„æ¶ˆæ¯');
        });
        
        // ç”¨æˆ·Bå›å¤Answer
        answerBButton.addEventListener('click', async () => {
            console.log('ç‚¹å‡»ï¼šç”¨æˆ·B - å›å¤ Answer');
            answerBButton.classList.add('clicked');
            answerBButton.disabled = true;
            try {
                const answer = await pcB.createAnswer();
                await pcB.setLocalDescription(answer);
                
                // é€šè¿‡Supabaseå‘é€Answer
                await channel.send({
                    type: 'broadcast',
                    event: 'webrtc_signal',
                    payload: {
                        from: 'B',
                        to: 'A',
                        type: 'answer',
                        data: answer
                    }
                });
                
                statusB.textContent = 'çŠ¶æ€: Answerå·²å‘é€';
                updateStepGuidance('è¯·åˆ‡æ¢åˆ°ç”¨æˆ·Aï¼Œç‚¹å‡»â€œ6. ç”¨æˆ·A - ç¡®è®¤ Answerâ€');
                
            } catch (err) {
                console.error('åˆ›å»ºAnswerå¤±è´¥:', err);
                statusB.textContent = `çŠ¶æ€: Answerå‘é€å¤±è´¥ - ${err.message}`;
                statusB.className = 'status error';
                updateStepGuidance('å‘ç”Ÿé”™è¯¯ï¼š' + err.message + 'ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•æˆ–æ£€æŸ¥æ­¥éª¤æ˜¯å¦é—æ¼');
            }
        });
        
        // å¤„ç†è¿œç¨‹Offer (ç”¨æˆ·B)
        async function handleRemoteOffer(offer) {
            if (!pcB) return;
            
            try {
                await pcB.setRemoteDescription(new RTCSessionDescription(offer));
                statusB.textContent = 'çŠ¶æ€: å·²æ¥æ”¶Offer';
                answerBButton.disabled = false; // è®©ç”¨æˆ·æ‰‹åŠ¨ç‚¹å‡»
                checkOfferBButton.disabled = false;
                
            } catch (err) {
                console.error('å¤„ç†Offerå¤±è´¥:', err);
                statusB.textContent = `çŠ¶æ€: å¤„ç†Offerå¤±è´¥ - ${err.message}`;
                statusB.className = 'status error';
                updateStepGuidance('å‘ç”Ÿé”™è¯¯ï¼š' + err.message + 'ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•æˆ–æ£€æŸ¥æ­¥éª¤æ˜¯å¦é—æ¼');
            }
        }
        
        // å¤„ç†è¿œç¨‹Answer (ç”¨æˆ·A)
        async function handleRemoteAnswer(answer) {
            if (!pcA) return;
            
            try {
                await pcA.setRemoteDescription(new RTCSessionDescription(answer));
                statusA.textContent = 'çŠ¶æ€: å·²æ¥æ”¶Answer';
                
                // ç›‘å¬è¿æ¥çŠ¶æ€
                pcA.onconnectionstatechange = () => {
                    if (pcA.connectionState === 'connected') {
                        statusA.textContent = 'çŠ¶æ€: P2Pè¿æ¥å·²å»ºç«‹!';
                    }
                };
                
            } catch (err) {
                console.error('å¤„ç†Answerå¤±è´¥:', err);
                statusA.textContent = `çŠ¶æ€: å¤„ç†Answerå¤±è´¥ - ${err.message}`;
                statusA.className = 'status error';
                updateStepGuidance('å‘ç”Ÿé”™è¯¯ï¼š' + err.message + 'ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•æˆ–æ£€æŸ¥æ­¥éª¤æ˜¯å¦é—æ¼');
            }
        }
    </script>
    <section id="signal-log" style="margin-top: 20px; padding: 10px; border: 1px solid #999; border-radius: 4px;">
      <h3>ğŸ“¡ æœ€è¿‘ Supabase ä¿¡ä»¤</h3>
      <pre id="signalLogContent" style="white-space: pre-wrap; background: #f9f9f9; padding: 10px; border-radius: 4px;"></pre>
    </section>
    <script>
    // æŸ¥çœ‹æœ€è¿‘ Supabase ä¿¡ä»¤ï¼ˆä¼˜åŒ–æ˜¾ç¤ºä¸å¥å£®æ€§ï¼‰
    viewLastSignalButton.addEventListener('click', () => {
        console.log('ç‚¹å‡»ï¼šæŸ¥çœ‹ Supabase æœ€è¿‘ä¿¡ä»¤');
        const display = document.getElementById('signalLogContent');
        if (!display) return;

        if (lastSupabasePayload) {
            const { type } = lastSupabasePayload;
            const iconMap = {
                offer: 'ğŸŸ¢',
                answer: 'ğŸ”µ',
                candidate: 'ğŸŸ '
            };
            const icon = iconMap[type] || 'â”';
            const pretty = JSON.stringify(lastSupabasePayload, null, 2);
            display.innerHTML = `<strong>${icon} ç±»å‹: ${type}</strong><br/><pre>${pretty}</pre>`;
        } else {
            display.innerHTML = '<em>å°šæœªæ”¶åˆ°ä»»ä½•ä¿¡ä»¤æ¶ˆæ¯</em>';
        }
    });
    </script>
</body>
</html>