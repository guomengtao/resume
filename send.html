<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>WebRTC Signal Debugger</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    textarea { width: 100%; height: 150px; }
    pre { background: #eee; padding: 10px; }
  </style>
</head>
<body>
    <div id="flowDescription" style="background:#f0f8ff; border:1px solid #ccc; padding:10px; margin-bottom:15px; font-size:14px; line-height:1.5; color:#333;">
        <strong>æµç¨‹è¯´æ˜ï¼š</strong><br>
        â€¢ å‘èµ·äººå†™å…¥ offer ä¿¡ä»¤åˆ° Supabaseã€‚<br>
        â€¢ åº”ç­”äººæ£€æµ‹åˆ° offer ä¿¡ä»¤ï¼Œè°ƒç”¨ peer.signal(offer)ï¼Œç”Ÿæˆ answerã€‚<br>
        â€¢ åº”ç­”äººå†™å…¥ answer ä¿¡ä»¤åˆ° Supabaseï¼ˆè¦†ç›–åŒä¸€æ¡è®°å½•çš„ signal å­—æ®µï¼‰ã€‚<br>
        â€¢ å‘èµ·äººç›‘å¬ Supabase çš„å˜åŒ–ï¼Œè¯»å–åˆ° answer ä¿¡ä»¤ï¼Œè°ƒç”¨ peer.signal(answer)ï¼Œå»ºç«‹è¿æ¥ã€‚
      </div>
  <h2>WebRTC æ‰‹åŠ¨ä¿¡ä»¤è°ƒè¯•å™¨</h2>
  <label>
    <input type="radio" name="role" value="initiator" checked /> å‘èµ·äºº
  </label>
  <label>
    <input type="radio" name="role" value="responder" /> åº”ç­”äºº
  </label>

  <div style="margin-top:10px;">
    <button id="startBtn">å¼€å§‹åˆ›å»º Peer</button>
    <button id="checkAnswerBtn" style="margin-top:10px;">æ‰‹åŠ¨ç›‘å¬åº”ç­”äººå›å¤</button>
    <button id="manualAnswerBtn" style="margin-top:10px;">æ‰‹åŠ¨å†™å…¥ç­”æ¡ˆ</button>
    <br/>
    <textarea id="manualAnswerInput" placeholder="åœ¨è¿™é‡Œç²˜è´´å¯¹æ–¹çš„ answer ä¿¡ä»¤ JSON" style="width:100%; height:100px; margin-top:5px;"></textarea>
  </div>
  <div id="countdown" style="margin-top:10px; font-weight: bold;"></div>

  <h3>æœ¬åœ°ç”Ÿæˆä¿¡ä»¤ (éœ€è¦å‘ç»™å¯¹æ–¹)</h3>
  <textarea id="localSignal" readonly></textarea>

  <h3>æ§åˆ¶å°æ—¥å¿—</h3>
  <pre id="log"></pre>

  <script type="module">
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm';
    const supabaseUrl = 'https://vbpbytebpaihpauwcryn.supabase.co';
    const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZicGJ5dGVicGFpaHBhdXdjcnluIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk0MjgzMzcsImV4cCI6MjA2NTAwNDMzN30.fW-XLBBgtUHtMWM_DYIowqz39SZpenkmgJfE_RZuc74';
    const supabase = createClient(supabaseUrl, supabaseKey);

    // ä¿¡ä»¤é€šé“ key
    const SIGNAL_ID = 'peer-signal';
    let peer = null;
    let role = null;

    function log(message) {
      console.log(message);
      const logElem = document.getElementById('log');
      logElem.textContent += message + '\n';
    }

    function startCountdown(seconds, onFinish) {
      const countdownElem = document.getElementById('countdown');
      let remaining = seconds;

      countdownElem.textContent = `ç­‰å¾…è¿æ¥ä¸­ï¼Œè¿˜å‰© ${remaining} ç§’...`;

      const interval = setInterval(() => {
        remaining--;
        if (remaining <= 0) {
          clearInterval(interval);
          countdownElem.textContent = 'å¼€å§‹è¿æ¥...';
          onFinish();
        } else {
          countdownElem.textContent = `ç­‰å¾…è¿æ¥ä¸­ï¼Œè¿˜å‰© ${remaining} ç§’...`;
        }
      }, 1000);
    }

    function tryConnect() {
      log('â³ å€’è®¡æ—¶ç»“æŸï¼Œå¼€å§‹å°è¯•è¿æ¥...');

      if (!peer) {
        log('âŒ Peer å¯¹è±¡ä¸å­˜åœ¨ï¼Œæ— æ³•è¿æ¥');
        document.getElementById('countdown').textContent = 'è¿æ¥å¤±è´¥ï¼šæ—  Peer å¯¹è±¡';
        return;
      }

      peer.on('connect', () => {
        log('âœ… Peer è¿æ¥æˆåŠŸï¼');
        document.getElementById('countdown').textContent = 'è¿æ¥æˆåŠŸï¼';
      });

      peer.on('error', err => {
        log('âŒ è¿æ¥é”™è¯¯: ' + err.message);
        document.getElementById('countdown').textContent = 'è¿æ¥å¤±è´¥ï¼š' + err.message;
      });
    }

    async function uploadToSupabase(signal) {
      let parsedSignal;
      try {
        parsedSignal = JSON.parse(signal);
      } catch (e) {
        log("âŒ ä¿¡ä»¤ JSON è§£æå¤±è´¥");
        return;
      }

      const record = {
        id: SIGNAL_ID,            // å›ºå®š id
        from: 'userA',            // å‘é€æ–¹ IDï¼Œç¤ºä¾‹å†™æ­»
        to: 'userB',              // æ¥æ”¶æ–¹ IDï¼Œç¤ºä¾‹å†™æ­»
        type: parsedSignal.type || 'unknown',
        data: parsedSignal,
        signal: signal
      };

      const { error } = await supabase
        .from('signals')
        .upsert(record, { onConflict: ['id'] });

      if (error) {
        log("âŒ Supabase å†™å…¥å¤±è´¥: " + error.message);
      } else {
        log("âœ… Supabase ä¿¡ä»¤å†™å…¥æˆåŠŸ");
        startCountdown(10, tryConnect);
      }
    }

    async function fetchFromSupabase() {
      const { data, error } = await supabase
        .from('signals')
        .select('signal')
        .eq('id', SIGNAL_ID)
        .single();
      if (error) log("âŒ Supabase è¯»å–å¤±è´¥: " + error.message);
      return { data, error };
    }

    document.getElementById('startBtn').onclick = async () => {
      role = document.querySelector('input[name="role"]:checked').value;
      log("ğŸ¯ è§’è‰²é€‰æ‹©: " + role);

      peer = new SimplePeer({ initiator: role === 'initiator', trickle: false });

      // ç›‘å¬ Supabase ä¿¡ä»¤å˜åŒ–ï¼Œå®æ—¶å¤„ç†å¯¹æ–¹ä¿¡ä»¤ï¼ˆæ–°ç‰ˆç›‘å¬æ–¹å¼ï¼‰
      const channel = supabase
        .channel('public:signals')
        .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'signals', filter: `id=eq.${SIGNAL_ID}` }, payload => {
          const signalData = payload.new.signal;
          const fromUser = payload.new.from;
          // åªå¤„ç†æ¥è‡ªå¯¹æ–¹çš„ä¿¡ä»¤
          if (fromUser !== (role === 'initiator' ? 'userA' : 'userB')) {
            try {
              const parsed = JSON.parse(signalData);
              peer.signal(parsed);
              log('â–¶ï¸ å¤„ç†å¯¹æ–¹ä¿¡ä»¤');

              // è‡ªåŠ¨æ›´æ–°æ‰‹åŠ¨è¾“å…¥æ¡†å†…å®¹ï¼Œæ–¹ä¾¿è°ƒè¯•å’Œé¿å…ç©ºå€¼æç¤º
              const manualAnswerInput = document.getElementById('manualAnswerInput');
              if (manualAnswerInput) {
                manualAnswerInput.value = signalData;
                log('ğŸ“¥ è‡ªåŠ¨æ›´æ–°ç­”æ¡ˆä¿¡ä»¤åˆ°æ–‡æœ¬æ¡†');
              }
            } catch {
              log('âŒ è§£æå¯¹æ–¹ä¿¡ä»¤å¤±è´¥');
            }
          }
        })
        .subscribe();

      peer.on('signal', data => {
        const encoded = JSON.stringify(data);
        log("ğŸ“¡ æœ¬åœ°ç”Ÿæˆä¿¡ä»¤å¹¶å†™å…¥ Supabase:");
        log(encoded);
        document.getElementById('localSignal').value = encoded;
        uploadToSupabase(encoded);
      });

      peer.on('connect', () => {
        log("âœ… Peer è¿æ¥æˆåŠŸï¼");
      });

      peer.on('error', err => {
        log("âŒ é”™è¯¯: " + err.message);
      });

      peer.on('data', data => {
        log("ğŸ“¥ æ”¶åˆ°æ•°æ®: " + data);
      });

      // å¦‚æœæ˜¯ responderï¼Œç«‹å³è¯»å– Supabase çœ‹æ˜¯å¦å·²æœ‰ offer
      if (role === 'responder') {
        const { data, error } = await fetchFromSupabase();
        const incoming = data?.signal;
        if (incoming) {
          try {
            const parsed = JSON.parse(incoming);
            log("ğŸ“¥ æ£€æµ‹åˆ° Supabase å·²å­˜åœ¨å¯¹æ–¹ offerï¼Œç«‹å³ signal:");
            log(JSON.stringify(parsed, null, 2));
            peer.signal(parsed);
          } catch (e) {
            log("âŒ JSON è§£æé”™è¯¯");
          }
        }
      }
    };
    // æ‰‹åŠ¨ç›‘å¬åº”ç­”äººå›å¤çš„å‡½æ•°
    async function manualCheckAnswer() {
      if (!peer) {
        log('âŒ Peer å¯¹è±¡ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰‹åŠ¨ç›‘å¬');
        return;
      }

      log('ğŸ” æ‰‹åŠ¨ç›‘å¬åº”ç­”äººå›å¤ä¿¡ä»¤...');

      const { data, error } = await supabase
        .from('signals')
        .select('signal, from')
        .eq('id', SIGNAL_ID)
        .single();

      if (error) {
        log('âŒ è¯»å– Supabase ä¿¡ä»¤å¤±è´¥: ' + error.message);
        return;
      }

      const fromUser = data.from;
      const signalStr = data.signal;

      if (fromUser === (role === 'initiator' ? 'userB' : 'userA')) {
        try {
          const parsed = JSON.parse(signalStr);
          peer.signal(parsed);
          log('â–¶ï¸ æ‰‹åŠ¨å¤„ç†å¯¹æ–¹ä¿¡ä»¤æˆåŠŸ');
        } catch (e) {
          log('âŒ è§£æä¿¡ä»¤å¤±è´¥');
        }
      } else {
        log('âš ï¸ è¯»å–åˆ°çš„æ˜¯è‡ªå·±å‘å‡ºçš„ä¿¡ä»¤ï¼Œæ— éœ€å¤„ç†');
      }
    }

    document.getElementById('checkAnswerBtn').onclick = manualCheckAnswer;

    async function manualInsertAnswer() {
      if (!peer) {
        log('âŒ Peer å¯¹è±¡ä¸å­˜åœ¨ï¼Œæ— æ³•å†™å…¥ç­”æ¡ˆ');
        return;
      }

      const answerStr = document.getElementById('manualAnswerInput').value.trim();
      if (!answerStr) {
        log('âŒ è¯·å…ˆå¡«å†™ç­”æ¡ˆä¿¡ä»¤ JSON');
        return;
      }

      try {
        const answer = JSON.parse(answerStr);

        if (peer.destroyed) {
          log('âŒ Peer å·²é”€æ¯ï¼Œæ— æ³•å†™å…¥ç­”æ¡ˆ');
          return;
        }

        // æ£€æŸ¥çŠ¶æ€ï¼Œé¿å… Called in wrong state
        if (peer._pc.signalingState === 'stable') {
          log('âŒ å½“å‰çŠ¶æ€ä¸º stableï¼Œä¸èƒ½è®¾ç½® remote answerï¼Œè¯·ç¡®ä¿å…ˆå¤„ç† offer');
          return;
        }

        try {
          peer.signal(answer);
          log('âœ… æ‰‹åŠ¨å†™å…¥ç­”æ¡ˆä¿¡ä»¤æˆåŠŸ');
        } catch (signalErr) {
          log('âŒ å‘é€ç­”æ¡ˆä¿¡ä»¤å¤±è´¥ï¼Œå¯èƒ½æ˜¯çŠ¶æ€ä¸å¯¹ï¼š' + signalErr.message);
        }
      } catch (e) {
        log('âŒ è§£æç­”æ¡ˆä¿¡ä»¤å¤±è´¥ï¼Œæ ¼å¼æœ‰è¯¯');
      }
    }

    document.getElementById('manualAnswerBtn').onclick = manualInsertAnswer;
  </script>
  <script src="https://cdn.jsdelivr.net/npm/simple-peer@9/simplepeer.min.js"></script>
</body>
</html>